/* * psp_osal.c * * Description: * * -------------------------------------------------------------------------- * *      Pthreads-embedded (PTE) - POSIX Threads Library for embedded systems *      Copyright(C) 2008 Jason Schmidlapp * *      Contact Email: jschmidlapp@users.sourceforge.net * *      This library is free software; you can redistribute it and/or *      modify it under the terms of the GNU Lesser General Public *      License as published by the Free Software Foundation; either *      version 2 of the License, or (at your option) any later version. * *      This library is distributed in the hope that it will be useful, *      but WITHOUT ANY WARRANTY; without even the implied warranty of *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *      Lesser General Public License for more details. * *      You should have received a copy of the GNU Lesser General Public *      License along with this library in the file COPYING.LIB; *      if not, write to the Free Software Foundation, Inc., *      59 Temple Place - Suite 330, Boston, MA 02111-1307, USA */#include <nanodesktop.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <pspkerror.h>#include "pte_osal.h"#include "pthread.h"#include "tls-helper.h"/* For ftime */#include <sys/time.h>#include <sys/types.h>#include <sys/timeb.h>#define MAX_PSP_UID 2048 // SWAG#define DEFAULT_STACK_SIZE_BYTES 4096#define PSP_MAX_TLS 32#if 1#define PSP_DEBUG(x) printf(x)#else#define PSP_DEBUG(x)#endif/* TLS key used to access pspThreadData struct for reach thread. */static unsigned int threadDataKey;/* * Data stored on a per-thread basis - allocated in pte_osThreadCreate * and freed in pte_osThreadDelete. */typedef struct pspThreadData  {    /* Entry point and parameters to thread's main function */    pte_osThreadEntryPoint entryPoint;    void * argv;    /* Semaphore used for cancellation.  Posted to by pte_osThreadCancel,        polled in pte_osSemaphoreCancellablePend */    SceUID cancelSem;  } pspThreadData;/* Structure used to emulate TLS on non-POSIX threads.   * This limits us to one non-POSIX thread that can * call pthread functions. */static void *globalTls;/* Helper functions */static pspThreadData *getThreadData(SceUID threadHandle);static void *getTlsStructFromThread(SceUID thid);/* A new thread's stub entry point.  It retrieves the real entry point from the per thread control * data as well as any parameters to this function, and then calls the entry point. */int pspStubThreadEntry (unsigned int argc, void *argv){  int result;  pspThreadData *pThreadData;  //pThreadData = getThreadData(sceKernelGetThreadId());  //result = (*(pThreadData->entryPoint))(pThreadData->argv);  //return result;    return -1;}/**************************************************************************** * * Initialization * ***************************************************************************/pte_osResult pte_osInit(void){  pte_osResult result;  pspThreadData *pThreadData;  char cancelSemName[64];  /* Allocate and initialize TLS support */  result = pteTlsGlobalInit(PSP_MAX_TLS);  if (result == PTE_OS_OK)  {    /* Allocate a key that we use to store control information (e.g. cancellation semaphore) per thread */    result = pteTlsAlloc(&threadDataKey);    if (result == PTE_OS_OK)      {	/* Initialize the structure used to emulate TLS for 	 * non-POSIX threads 	 */	globalTls = pteTlsThreadInit();	/* Also create a "thread data" structure for a single non-POSIX thread. */	/* Allocate some memory for our per-thread control data.  We use this for:	 * 1. Entry point and parameters for the user thread's main function.	 * 2. Semaphore used for thread cancellation.	 */	pThreadData = (pspThreadData *) malloc(sizeof(pspThreadData));		if (pThreadData == NULL)	  {	    result = PTE_OS_NO_RESOURCES;	  }	else	  {	    /* Save a pointer to our per-thread control data as a TLS value */	    pteTlsSetValue(globalTls, threadDataKey, pThreadData);		    /* Create a semaphore used to cancel threads */	    snprintf(cancelSemName, sizeof(cancelSemName), "pthread_cancelSemGlobal");	    	    /*	    pThreadData->cancelSem = sceKernelCreateSema(cancelSemName,							 0,          // attributes (default) 							 0,          // initial value        							 255,        // maximum value        							 0);         // options (default)            */							 	    result = PTE_OS_OK;	  }      }  }  return result;}/**************************************************************************** * * Threads * ***************************************************************************/pte_osResult pte_osThreadCreate(pte_osThreadEntryPoint entryPoint,                                int stackSize,                                int initialPriority,                                void *argv,                                pte_osThreadHandle* ppte_osThreadHandle){  return PTE_OS_GENERAL_FAILURE;}pte_osResult pte_osThreadStart(pte_osThreadHandle osThreadHandle){  return -1;}pte_osResult pte_osThreadDelete(pte_osThreadHandle handle){  return PTE_OS_OK;}pte_osResult pte_osThreadExitAndDelete(pte_osThreadHandle handle){  return PTE_OS_OK;}void pte_osThreadExit(){}/* * This has to be cancellable, so we can't just call sceKernelWaitThreadEnd. * Instead, poll on this in a loop, like we do for a cancellable semaphore. */pte_osResult pte_osThreadWaitForEnd(pte_osThreadHandle threadHandle){    return PTE_OS_GENERAL_FAILURE;}pte_osThreadHandle pte_osThreadGetHandle(void){  return -1;}int pte_osThreadGetPriority(pte_osThreadHandle threadHandle){  return -1;}pte_osResult pte_osThreadSetPriority(pte_osThreadHandle threadHandle, int newPriority){  return PTE_OS_GENERAL_FAILURE;}pte_osResult pte_osThreadCancel(pte_osThreadHandle threadHandle){  return PTE_OS_GENERAL_FAILURE;}pte_osResult pte_osThreadCheckCancel(pte_osThreadHandle threadHandle){  return PTE_OS_GENERAL_FAILURE;}void pte_osThreadSleep(unsigned int msecs){  ndHAL_Delay ( (float)(msecs)/1000.0 );}int pte_osThreadGetMinPriority(){  return 17;}int pte_osThreadGetMaxPriority(){  return 30;}int pte_osThreadGetDefaultPriority(){  return 18;}/**************************************************************************** * * Mutexes * ****************************************************************************/pte_osResult pte_osMutexCreate(pte_osMutexHandle *pHandle){  return -1;}pte_osResult pte_osMutexDelete(pte_osMutexHandle handle){  return -1;}pte_osResult pte_osMutexLock(pte_osMutexHandle handle){  return -1;}pte_osResult pte_osMutexTimedLock(pte_osMutexHandle handle, unsigned int timeoutMsecs){  return PTE_OS_TIMEOUT;}pte_osResult pte_osMutexUnlock(pte_osMutexHandle handle){  return -1;}/**************************************************************************** * * Semaphores * ***************************************************************************/pte_osResult pte_osSemaphoreCreate(int initialValue, pte_osSemaphoreHandle *pHandle){  return -1;}pte_osResult pte_osSemaphoreDelete(pte_osSemaphoreHandle handle){  return -1;}pte_osResult pte_osSemaphorePost(pte_osSemaphoreHandle handle, int count){  return -1;}pte_osResult pte_osSemaphorePend(pte_osSemaphoreHandle handle, unsigned int *pTimeoutMsecs){  return PTE_OS_GENERAL_FAILURE;}/* * Pend on a semaphore- and allow the pend to be cancelled. * * PSP OS provides no functionality to asynchronously interrupt a blocked call.  We simulte * this by polling on the main semaphore and the cancellation semaphore and sleeping in a loop. */pte_osResult pte_osSemaphoreCancellablePend(pte_osSemaphoreHandle semHandle, unsigned int *pTimeout){  return PTE_OS_GENERAL_FAILURE;}/**************************************************************************** * * Atomic Operations * ***************************************************************************/int pte_osAtomicExchange(int *ptarg, int val){  int origVal;  origVal = *ptarg;  *ptarg = val;  return origVal;}int pte_osAtomicCompareExchange(int *pdest, int exchange, int comp){  int origVal;  origVal = *pdest;  if (*pdest == comp)    {      *pdest = exchange;    }  return origVal;}int pte_osAtomicExchangeAdd(int volatile* pAddend, int value){  int origVal;    origVal = *pAddend;  *pAddend += value;    return origVal;}int pte_osAtomicDecrement(int *pdest){  int val;    (*pdest)--;  val = *pdest;    return val;}int pte_osAtomicIncrement(int *pdest){  int val;    (*pdest)++;  val = *pdest;    return val;}/**************************************************************************** * * Helper functions * ***************************************************************************/static pspThreadData *getThreadData(SceUID threadHandle){  return 0;}static void *getTlsStructFromThread(SceUID thid){  return 0;}/**************************************************************************** * * Thread Local Storage * ***************************************************************************/pte_osResult pte_osTlsSetValue(unsigned int key, void * value){  void *pTls;  pTls = getTlsStructFromThread(sceKernelGetThreadId());  return pteTlsSetValue(pTls, key, value);}void * pte_osTlsGetValue(unsigned int index){  //void *pTls;  //pTls = getTlsStructFromThread(sceKernelGetThreadId());  //return (void *) pteTlsGetValue(pTls, index);  return PTE_OS_GENERAL_FAILURE;}pte_osResult pte_osTlsAlloc(unsigned int *pKey){  //void * pTls;  //pTls = getTlsStructFromThread(sceKernelGetThreadId());  //return pteTlsAlloc(pKey);  return PTE_OS_GENERAL_FAILURE;}pte_osResult pte_osTlsFree(unsigned int index){  return pteTlsFree(index);}/**************************************************************************** * * Miscellaneous * ***************************************************************************/int ftime(struct timeb *tb){  struct timeval tv;  struct timezone tz;  gettimeofday(&tv, &tz);  tb->time = tv.tv_sec;  tb->millitm = tv.tv_usec / 1000;  tb->timezone = tz.tz_minuteswest;  tb->dstflag = tz.tz_dsttime;  return 0;}